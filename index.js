// ======================================================
// Geata API - index.js
// Node.js + Express + Postgres (Supabase Postgres via DATABASE_URL)
// ------------------------------------------------------
// This is a single-file backend (monolithic) for simplicity.
// It provides:
//  - Admin API (x-api-key protected): manage users, gates, schedules, events, alerts
//  - User API (JWT Bearer token): login, list devices, send OPEN/AUX commands, read alerts/events
//  - Device poll API (ESP32): pull queued commands + report command results
//
// NOTE: Email is intentionally REMOVED in this version.
//       Alerts are delivered via polling endpoints (e.g. /me/alerts, /admin/alerts).
// ======================================================

const express = require("express");
const path = require("path");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { Pool } = require("pg");
const crypto = require("crypto");
const ExcelJS = require("exceljs");

// ======================================================
// 1) App + config
// ======================================================

const app = express();
app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

const BUILD_TAG = process.env.BUILD_TAG || "local-dev";

const ADMIN_API_KEY = process.env.ADMIN_API_KEY || "dev-only-admin-key";
const JWT_SECRET = process.env.JWT_SECRET || "dev-only-jwt-secret";
const PORT = process.env.PORT || 3000;

const DATABASE_URL = process.env.DATABASE_URL;
if (!DATABASE_URL) {
  console.warn("*** WARNING: DATABASE_URL is not set (Postgres will not connect). ***");
}

// PGSSL=true in Render env is a common pattern
const PGSSL = String(process.env.PGSSL || "").toLowerCase() === "true";
const useSSL = PGSSL || process.env.NODE_ENV === "production";

// Create a Postgres connection pool (Supabase Postgres is still "normal Postgres")
const pool = new Pool({
  connectionString: DATABASE_URL,
  ssl: useSSL ? { rejectUnauthorized: false } : false,
});

// Serve admin UI at /
app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "admin.html"));
});

// ======================================================
// 2) Small utility helpers
// ======================================================

// Wrap async route handlers so errors go to Express error handler
function asyncHandler(fn) {
  return (req, res, next) => Promise.resolve(fn(req, res, next)).catch(next);
}

// Query helpers
async function q(text, params = []) {
  return pool.query(text, params);
}
async function one(text, params = []) {
  const r = await q(text, params);
  return r.rows[0] || null;
}

// Misc helpers
function normalizePhone(raw) {
  if (!raw) return null;
  return String(raw).trim();
}

function randomId(prefix) {
  return prefix + "_" + Date.now() + "_" + Math.floor(Math.random() * 100000);
}

function shortHash(s) {
  return crypto.createHash("sha256").update(String(s || "")).digest("hex").slice(0, 10);
}

// ======================================================
// 3) Middleware: Admin key + User JWT
// ======================================================

// Admin endpoints require x-api-key header
function requireAdminKey(req, res, next) {
  const key = req.header("x-api-key");
  if (!key || key !== ADMIN_API_KEY) {
    return res.status(401).json({ error: "Unauthorized: missing or invalid API key" });
  }
  next();
}

// User endpoints require Authorization: Bearer <token>
function requireUser(req, res, next) {
  const auth = req.header("authorization") || "";
  if (!auth.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Missing auth token" });
  }
  const token = auth.slice(7);
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = { id: payload.userId };
    next();
  } catch (err) {
    return res.status(401).json({ error: "Invalid or expired token" });
  }
}

// ======================================================
// 4) DB init (creates tables if missing)
// ------------------------------------------------------
// In Supabase, you normally create tables via SQL editor.
// This initDb is safe (CREATE TABLE IF NOT EXISTS) and
// helps local-dev or fresh installs.
// ======================================================

async function initDb() {
  await q(`
    CREATE TABLE IF NOT EXISTS devices (
      id   TEXT PRIMARY KEY,
      name TEXT NOT NULL
    );

    CREATE TABLE IF NOT EXISTS users (
      id            TEXT PRIMARY KEY,
      name          TEXT NOT NULL,
      email         TEXT UNIQUE,
      phone         TEXT,
      password_hash TEXT
    );

    CREATE TABLE IF NOT EXISTS schedules (
      id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      name        TEXT NOT NULL,
      description TEXT,
      created_at  TEXT NOT NULL
    );

    CREATE TABLE IF NOT EXISTS schedule_slots (
      id           INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      schedule_id  INTEGER NOT NULL REFERENCES schedules(id) ON DELETE CASCADE,
      days_of_week TEXT,
      start        TEXT NOT NULL,
      "end"        TEXT NOT NULL
    );

    CREATE TABLE IF NOT EXISTS device_users (
      device_id   TEXT NOT NULL REFERENCES devices(id) ON DELETE CASCADE,
      user_id     TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      role        TEXT NOT NULL,
      schedule_id INTEGER REFERENCES schedules(id) ON DELETE SET NULL,
      PRIMARY KEY (device_id, user_id)
    );

    CREATE TABLE IF NOT EXISTS commands (
      id           TEXT PRIMARY KEY,
      device_id    TEXT NOT NULL REFERENCES devices(id) ON DELETE CASCADE,
      user_id      TEXT REFERENCES users(id) ON DELETE SET NULL,
      type         TEXT NOT NULL,
      status       TEXT NOT NULL,
      requested_at TEXT NOT NULL,
      completed_at TEXT,
      result       TEXT,
      duration_ms  INTEGER NOT NULL
    );

    CREATE TABLE IF NOT EXISTS device_settings (
      device_id  TEXT PRIMARY KEY REFERENCES devices(id) ON DELETE CASCADE,
      settings   JSONB NOT NULL DEFAULT '{}'::jsonb,
      updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
    );

    CREATE TABLE IF NOT EXISTS device_events (
      id         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      device_id  TEXT NOT NULL REFERENCES devices(id) ON DELETE CASCADE,
      user_id    TEXT REFERENCES users(id) ON DELETE SET NULL,
      event_type TEXT NOT NULL,
      at         TEXT NOT NULL,
      details    TEXT
    );

    CREATE TABLE IF NOT EXISTS device_notifications_subscriptions (
      device_id  TEXT NOT NULL REFERENCES devices(id) ON DELETE CASCADE,
      user_id    TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      event_type TEXT NOT NULL,
      enabled    BOOLEAN NOT NULL DEFAULT TRUE,
      PRIMARY KEY (device_id, user_id, event_type)
    );

    CREATE INDEX IF NOT EXISTS idx_device_users_user ON device_users(user_id);
    CREATE INDEX IF NOT EXISTS idx_commands_device_status_req ON commands(device_id, status, requested_at);
    CREATE INDEX IF NOT EXISTS idx_device_events_device_at ON device_events(device_id, at);
    CREATE INDEX IF NOT EXISTS idx_device_events_user_at ON device_events(user_id, at);
    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
    CREATE INDEX IF NOT EXISTS idx_users_phone ON users(phone);
    CREATE INDEX IF NOT EXISTS idx_notify_device_event ON device_notifications_subscriptions(device_id, event_type);
  `);

  // Optional seed devices if table is empty (handy for local testing)
  const row = await one("SELECT COUNT(*)::int AS c FROM devices");
  if ((row?.c || 0) === 0) {
    await q(
      `INSERT INTO devices (id, name) VALUES ($1,$2),($3,$4)
       ON CONFLICT (id) DO NOTHING`,
      ["gate1", "Example Gate 1", "gate2", "Example Gate 2"]
    );
  }
}

// ======================================================
// 5) Data access functions (Devices / Users / Membership / Schedules)
// ======================================================

// ---------- Devices ----------
async function getDevices() {
  const r = await q("SELECT id, name FROM devices ORDER BY id");
  return r.rows;
}

async function getDeviceById(id) {
  return one("SELECT id, name FROM devices WHERE id = $1", [id]);
}

// Case-insensitive compare on trimmed name
async function getDeviceByName(name) {
  const nm = (name || "").trim();
  if (!nm) return null;

  const r = await q(
    "SELECT id, name FROM devices WHERE lower(trim(name)) = lower(trim($1)) LIMIT 1",
    [nm]
  );
  return r.rows[0] || null;
}

async function createDevice(id, name) {
  await q("INSERT INTO devices (id, name) VALUES ($1, $2)", [id, name]);
  return getDeviceById(id);
}

// NOTE: delete gate should be implemented later (soft-delete recommended).
// For now, you can delete directly from DB if needed.

// ---------- Users ----------
async function getUserById(id) {
  return one("SELECT * FROM users WHERE id = $1", [id]);
}

async function getUserByEmail(email) {
  if (!email) return null;
  return one("SELECT * FROM users WHERE email = $1", [email]);
}

async function getUserByPhone(phone) {
  const p = normalizePhone(phone);
  if (!p) return null;
  return one("SELECT * FROM users WHERE phone = $1", [p]);
}

async function createUser({ name, email, phone, password }) {
  const id = randomId("u");
  const normalizedPhone = normalizePhone(phone);
  const hash = password ? bcrypt.hashSync(password, 10) : null;

  await q(
    "INSERT INTO users (id, name, email, phone, password_hash) VALUES ($1,$2,$3,$4,$5)",
    [id, name || email || normalizedPhone || id, email || null, normalizedPhone || null, hash]
  );

  return getUserById(id);
}

async function updateUser(id, { name, email, phone, password }) {
  const user = await getUserById(id);
  if (!user) return null;

  const newName = name != null && name !== "" ? name : user.name;
  const newEmail = email != null && email !== "" ? email : user.email;
  const newPhone = phone != null && phone !== "" ? normalizePhone(phone) : user.phone;

  let newHash = user.password_hash;
  if (password && password.length > 0) {
    newHash = bcrypt.hashSync(password, 10);
  }

  await q(
    "UPDATE users SET name=$1, email=$2, phone=$3, password_hash=$4 WHERE id=$5",
    [newName, newEmail, newPhone, newHash, id]
  );

  return getUserById(id);
}

// HARD delete user (you asked earlier for soft delete, but you’re currently deleting).
// We keep this for now because you said it “works now”.
// When you’re ready for SOFT delete, we’ll add users.deleted_at and filter.
async function deleteUserHard(userId) {
  // delete dependencies first (order matters)
  await q("DELETE FROM device_users WHERE user_id = $1", [userId]);
  await q("DELETE FROM device_notifications_subscriptions WHERE user_id = $1", [userId]);
  await q("DELETE FROM notification_outbox WHERE user_id = $1").catch(() => {}); // optional table
  await q("DELETE FROM commands WHERE user_id = $1", [userId]);

  // If you want to preserve history, DO NOT delete device_events here.
  // await q("DELETE FROM device_events WHERE user_id = $1", [userId]);

  await q("DELETE FROM users WHERE id = $1", [userId]);
}

async function searchUsers(qstr) {
  if (!qstr) {
    const r = await q("SELECT * FROM users ORDER BY LOWER(name)");
    return r.rows;
  }
  const pattern = "%" + qstr + "%";
  const r = await q(
    `
    SELECT *
    FROM users
    WHERE name  ILIKE $1
       OR email ILIKE $1
       OR phone ILIKE $1
       OR id    ILIKE $1
    ORDER BY LOWER(name)
    `,
    [pattern]
  );
  return r.rows;
}

// ---------- Device Users ----------
async function attachUserToDevice(deviceId, userId, role) {
  const rRole = role || "operator";
  await q(
    `
    INSERT INTO device_users (device_id, user_id, role)
    VALUES ($1,$2,$3)
    ON CONFLICT (device_id, user_id) DO NOTHING
    `,
    [deviceId, userId, rRole]
  );
  return { deviceId, userId, role: rRole };
}

async function detachUserFromDevice(deviceId, userId) {
  const r = await q("DELETE FROM device_users WHERE device_id=$1 AND user_id=$2", [deviceId, userId]);
  return r.rowCount > 0;
}

async function setDeviceUserSchedule(deviceId, userId, scheduleId) {
  await q(
    `
    UPDATE device_users
    SET schedule_id = $1
    WHERE device_id = $2 AND user_id = $3
    `,
    [scheduleId || null, deviceId, userId]
  );
}

async function listDeviceUsers(deviceId) {
  const r = await q(
    `
    SELECT
      du.user_id     AS "userId",
      du.role        AS "role",
      du.schedule_id AS "scheduleId",
      u.name         AS "name",
      u.email        AS "email",
      u.phone        AS "phone"
    FROM device_users du
    LEFT JOIN users u ON u.id = du.user_id
    WHERE du.device_id = $1
    ORDER BY LOWER(u.name)
    `,
    [deviceId]
  );
  return r.rows;
}

async function listUserDevices(userId) {
  const r = await q(
    `
    SELECT du.device_id AS "deviceId",
           du.role      AS "role"
    FROM device_users du
    WHERE du.user_id = $1
    ORDER BY du.device_id
    `,
    [userId]
  );
  return r.rows;
}

async function isUserOnDevice(deviceId, userId) {
  const row = await one("SELECT 1 AS present FROM device_users WHERE device_id=$1 AND user_id=$2", [deviceId, userId]);
  return !!row;
}

async function getDeviceUserScheduleId(deviceId, userId) {
  const row = await one("SELECT schedule_id FROM device_users WHERE device_id=$1 AND user_id=$2", [deviceId, userId]);
  return row ? row.schedule_id : null;
}

// ---------- Schedules ----------
async function getScheduleSlots(scheduleId) {
  const r = await q(
    `
    SELECT id, schedule_id, days_of_week, start, "end" AS end
    FROM schedule_slots
    WHERE schedule_id = $1
    ORDER BY id
    `,
    [scheduleId]
  );
  return r.rows;
}

async function getScheduleById(id) {
  const row = await one("SELECT id, name, description, created_at FROM schedules WHERE id = $1", [id]);
  if (!row) return null;

  const slotsRows = await getScheduleSlots(id);
  const slots = slotsRows.map((s) => ({
    id: s.id,
    scheduleId: s.schedule_id,
    daysOfWeek: s.days_of_week ? JSON.parse(s.days_of_week) : [],
    start: s.start,
    end: s.end,
  }));

  return { id: row.id, name: row.name, description: row.description, createdAt: row.created_at, slots };
}

async function listSchedules() {
  const r = await q("SELECT id, name, description, created_at FROM schedules ORDER BY LOWER(name)");
  const out = [];
  for (const sched of r.rows) {
    const slotsRows = await getScheduleSlots(sched.id);
    const slots = slotsRows.map((s) => ({
      id: s.id,
      scheduleId: s.schedule_id,
      daysOfWeek: s.days_of_week ? JSON.parse(s.days_of_week) : [],
      start: s.start,
      end: s.end,
    }));
    out.push({ id: sched.id, name: sched.name, description: sched.description, createdAt: sched.created_at, slots });
  }
  return out;
}

async function createSchedule({ name, description, slots }) {
  const createdAt = new Date().toISOString();
  const info = await one(
    `
    INSERT INTO schedules (name, description, created_at)
    VALUES ($1,$2,$3)
    RETURNING id
    `,
    [name, description || null, createdAt]
  );
  const scheduleId = info.id;

  if (Array.isArray(slots)) {
    for (const s of slots) {
      const daysJson = Array.isArray(s.daysOfWeek) && s.daysOfWeek.length > 0 ? JSON.stringify(s.daysOfWeek) : null;
      await q(`INSERT INTO schedule_slots (schedule_id, days_of_week, start, "end") VALUES ($1,$2,$3,$4)`, [
        scheduleId,
        daysJson,
        s.start,
        s.end,
      ]);
    }
  }
  return getScheduleById(scheduleId);
}

async function updateSchedule(id, { name, description, slots }) {
  const existing = await getScheduleById(id);
  if (!existing) return null;

  await q("UPDATE schedules SET name=$1, description=$2 WHERE id=$3", [name || existing.name, description || null, id]);
  await q("DELETE FROM schedule_slots WHERE schedule_id = $1", [id]);

  if (Array.isArray(slots)) {
    for (const s of slots) {
      const daysJson = Array.isArray(s.daysOfWeek) && s.daysOfWeek.length > 0 ? JSON.stringify(s.daysOfWeek) : null;
      await q(`INSERT INTO schedule_slots (schedule_id, days_of_week, start, "end") VALUES ($1,$2,$3,$4)`, [
        id,
        daysJson,
        s.start,
        s.end,
      ]);
    }
  }
  return getScheduleById(id);
}

async function deleteSchedule(id) {
  await q("UPDATE device_users SET schedule_id = NULL WHERE schedule_id = $1", [id]);
  await q("DELETE FROM schedule_slots WHERE schedule_id = $1", [id]);
  await q("DELETE FROM schedules WHERE id = $1", [id]);
}

// ---------- Schedule check (enforces access windows) ----------
async function isUserAllowedNow(deviceId, userId, now) {
  now = now || new Date();

  if (!(await isUserOnDevice(deviceId, userId))) return false;

  const scheduleId = await getDeviceUserScheduleId(deviceId, userId);
  if (!scheduleId) return true; // no schedule means 24/7

  const sched = await getScheduleById(scheduleId);
  if (!sched || !sched.slots || sched.slots.length === 0) return false;

  const day = now.getDay(); // 0–6
  const hh = now.getHours();
  const mm = now.getMinutes();
  const pad = (n) => (n < 10 ? "0" + n : "" + n);
  const timeStr = pad(hh) + ":" + pad(mm);

  for (const s of sched.slots) {
    const days = Array.isArray(s.daysOfWeek) ? s.daysOfWeek : [];
    if (days.length > 0 && days.indexOf(day) === -1) continue;
    if (s.start && timeStr < s.start) continue;
    if (s.end && timeStr > s.end) continue;
    return true;
  }
  return false;
}

// ======================================================
// 6) Alerts + Events reporting helpers
// ------------------------------------------------------
// Alerts are "derived" from device_events + subscriptions table.
// No email: clients poll /me/alerts (user) or /admin/alerts (admin).
// ======================================================

async function getUserAlerts({ userId, deviceId = null, since = null, limit = 200 }) {
  const params = [userId];
  let p = 2;

  let where = `1=1`;
  if (deviceId) {
    where += ` AND e.device_id = $${p}`;
    params.push(deviceId);
    p++;
  }
  if (since) {
    where += ` AND e.at > $${p}`;
    params.push(since);
    p++;
  }

  params.push(limit);

  const sql = `
    SELECT
      e.id,
      e.device_id,
      d.name AS device_name,
      e.user_id,
      u.name AS user_name,
      u.email AS user_email,
      u.phone AS user_phone,
      e.event_type,
      e.at,
      e.details
    FROM device_events e
    JOIN device_notifications_subscriptions s
      ON s.device_id = e.device_id
     AND s.user_id   = $1
     AND s.event_type = e.event_type
     AND s.enabled = true
    LEFT JOIN devices d ON d.id = e.device_id
    LEFT JOIN users u   ON u.id = e.user_id
    WHERE ${where}
    ORDER BY e.at DESC
    LIMIT $${p}
  `;

  const r = await q(sql, params);
  return r.rows;
}

async function getAdminAlerts({ deviceId = null, userId = null, from = null, to = null, limit = 500 }) {
  const params = [];
  let p = 1;
  let where = `1=1`;

  if (deviceId) {
    where += ` AND e.device_id = $${p}`;
    params.push(deviceId);
    p++;
  }
  if (userId) {
    where += ` AND e.user_id = $${p}`;
    params.push(userId);
    p++;
  }
  if (from) {
    where += ` AND e.at >= $${p}`;
    params.push(from);
    p++;
  }
  if (to) {
    where += ` AND e.at <= $${p}`;
    params.push(to);
    p++;
  }

  params.push(limit);

  const sql = `
    SELECT
      e.id,
      e.device_id,
      d.name AS device_name,
      e.user_id,
      u.name AS user_name,
      u.email AS user_email,
      u.phone AS user_phone,
      e.event_type,
      e.at,
      e.details
    FROM device_events e
    LEFT JOIN devices d ON d.id = e.device_id
    LEFT JOIN users u   ON u.id = e.user_id
    WHERE ${where}
    ORDER BY e.at DESC
    LIMIT $${p}
  `;

  const r = await q(sql, params);
  return r.rows;
}

// Fetch device events (simple recent list)
async function getDeviceEvents(deviceId, limit) {
  const lim = limit || 50;
  const r = await q(
    `
    SELECT
      e.id, e.device_id, e.user_id, e.event_type, e.at, e.details,
      u.name  AS user_name,
      u.phone AS user_phone
    FROM device_events e
    LEFT JOIN users u ON u.id = e.user_id
    WHERE e.device_id = $1
    ORDER BY e.at DESC
    LIMIT $2
    `,
    [deviceId, lim]
  );
  return r.rows;
}

// General report query for events screen
async function getEventsForReport(filters) {
  const deviceId = filters.deviceId || null;
  const userId = filters.userId || null;
  const from = filters.from || null;
  const to = filters.to || null;
  const limit = filters.limit || 500;

  let sql = `
    SELECT
      e.id, e.device_id, e.user_id, e.event_type, e.at, e.details,
      u.name  AS user_name,
      u.phone AS user_phone,
      u.email AS user_email,
      d.name  AS device_name
    FROM device_events e
    LEFT JOIN users   u ON u.id = e.user_id
    LEFT JOIN devices d ON d.id = e.device_id
    WHERE 1=1
  `;

  const params = [];
  let i = 1;

  if (deviceId) {
    sql += ` AND e.device_id = $${i++}`;
    params.push(deviceId);
  }
  if (userId) {
    sql += ` AND e.user_id = $${i++}`;
    params.push(userId);
  }
  if (from) {
    sql += ` AND e.at >= $${i++}`;
    params.push(from);
  }
  if (to) {
    sql += ` AND e.at <= $${i++}`;
    params.push(to);
  }

  sql += ` ORDER BY e.at DESC LIMIT $${i++}`;
  params.push(limit);

  const r = await q(sql, params);
  return r.rows;
}

// CSV helper
function toCsv(rows) {
  const header = ["at", "device_id", "device_name", "user_id", "user_name", "user_phone", "event_type", "details"];
  const esc = (v) => {
    const s = (v ?? "").toString();
    if (s.includes('"') || s.includes(",") || s.includes("\n")) return `"${s.replace(/"/g, '""')}"`;
    return s;
  };

  const lines = [header.join(",")];
  for (const r of rows || []) {
    lines.push(
      [
        esc(r.at),
        esc(r.device_id),
        esc(r.device_name),
        esc(r.user_id),
        esc(r.user_name),
        esc(r.user_phone),
        esc(r.event_type),
        esc(r.details),
      ].join(",")
    );
  }
  return lines.join("\n");
}

// ======================================================
// 7) Commands (queued actions for ESP32) + event logging
// ======================================================

// Log an event (no email side effects)
async function logDeviceEvent(deviceId, eventType, opts) {
  opts = opts || {};
  const userId = opts.userId || null;
  const details = opts.details || null;
  const at = new Date().toISOString();

  await q(
    `INSERT INTO device_events (device_id, user_id, event_type, at, details)
     VALUES ($1,$2,$3,$4,$5)`,
    [deviceId, userId, eventType, at, details]
  );
}

// Create a queued command (device will fetch these via /device/poll)
async function createCommand(deviceId, userId, type, durationMs) {
  const id = randomId("cmd");
  const nowIso = new Date().toISOString();

  await q(
    `INSERT INTO commands
      (id, device_id, user_id, type, status, requested_at, completed_at, result, duration_ms)
     VALUES ($1,$2,$3,$4,'queued',$5,NULL,NULL,$6)`,
    [id, deviceId, userId || null, type, nowIso, durationMs]
  );

  await logDeviceEvent(deviceId, "CMD_REQUESTED", {
    userId: userId || null,
    details: `type=${type};durationMs=${durationMs}`,
  });

  return {
    id,
    deviceId,
    userId: userId || null,
    type,
    status: "queued",
    requestedAt: nowIso,
    completedAt: null,
    result: null,
    durationMs,
  };
}

async function getQueuedCommands(deviceId) {
  const r = await q(
    `SELECT * FROM commands
     WHERE device_id=$1 AND status='queued'
     ORDER BY requested_at ASC`,
    [deviceId]
  );
  return r.rows;
}

async function completeCommand(deviceId, commandId, result) {
  const nowIso = new Date().toISOString();
  await q(
    `UPDATE commands
     SET status='completed', completed_at=$1, result=$2
     WHERE id=$3 AND device_id=$4 AND status='queued'`,
    [nowIso, result || null, commandId, deviceId]
  );
  return one("SELECT * FROM commands WHERE id = $1", [commandId]);
}

// ======================================================
// 8) Profile endpoint for admin UI (no N+1 loops)
// ======================================================

async function getUserProfile(userId) {
  const user = await one(
    `SELECT id, name, email, phone
     FROM users
     WHERE id = $1`,
    [userId]
  );
  if (!user) return null;

  const row = await one(
    `
    WITH device_rows AS (
      SELECT
        du.device_id,
        d.name AS device_name,
        du.role,
        du.schedule_id
      FROM device_users du
      JOIN devices d ON d.id = du.device_id
      WHERE du.user_id = $1
    ),
    subs AS (
      SELECT
        ns.device_id,
        json_agg(ns.event_type ORDER BY ns.event_type) AS event_types
      FROM device_notifications_subscriptions ns
      WHERE ns.user_id = $1
        AND ns.enabled = TRUE
      GROUP BY ns.device_id
    ),
    sched AS (
      SELECT
        s.id,
        s.name,
        s.description,
        s.created_at,
        COALESCE(
          json_agg(
            json_build_object(
              'id', ss.id,
              'daysOfWeek', COALESCE(ss.days_of_week::json, '[]'::json),
              'start', ss.start,
              'end', ss."end"
            )
            ORDER BY ss.id
          ) FILTER (WHERE ss.id IS NOT NULL),
          '[]'::json
        ) AS slots
      FROM schedules s
      LEFT JOIN schedule_slots ss ON ss.schedule_id = s.id
      GROUP BY s.id
    )
    SELECT
      COALESCE(
        json_agg(
          json_build_object(
            'deviceId', dr.device_id,
            'deviceName', dr.device_name,
            'role', dr.role,

            'scheduleAssignment', json_build_object(
              'scheduleId', dr.schedule_id,
              'mode', CASE WHEN dr.schedule_id IS NULL THEN 'ALWAYS' ELSE 'SCHEDULE' END
            ),

            'schedule',
              CASE
                WHEN dr.schedule_id IS NULL THEN NULL
                ELSE json_build_object(
                  'id', sc.id,
                  'name', sc.name,
                  'description', sc.description,
                  'createdAt', sc.created_at,
                  'slots', sc.slots
                )
              END,

            'notifications', json_build_object(
              'eventTypes', COALESCE(sb.event_types, '[]'::json)
            )
          )
          ORDER BY dr.device_id
        ),
        '[]'::json
      ) AS devices
    FROM device_rows dr
    LEFT JOIN subs sb ON sb.device_id = dr.device_id
    LEFT JOIN sched sc ON sc.id = dr.schedule_id
    `,
    [userId]
  );

  return { user, devices: row?.devices || [] };
}

// ======================================================
// 9) Routes
// ======================================================

// ---- Build Tag ----
app.get("/__build", (req, res) => {
  res.json({
    buildTag: BUILD_TAG,
    node: process.version,
    time: new Date().toISOString(),
  });
});

// -------------------------
// Auth (Admin-controlled register)
// -------------------------
app.post(
  "/auth/register",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const { name, email, phone, password } = req.body || {};
    if (!password || (!email && !phone)) {
      return res.status(400).json({ error: "password and at least phone or email are required" });
    }

    const normalizedPhone = normalizePhone(phone);

    // Prevent duplicates
    if (normalizedPhone) {
      const existingByPhone = await getUserByPhone(normalizedPhone);
      if (existingByPhone) return res.status(409).json({ error: "User with this phone already exists" });
    }
    if (email) {
      const existingByEmail = await getUserByEmail(email);
      if (existingByEmail) return res.status(409).json({ error: "User with this email already exists" });
    }

    const user = await createUser({ name, email, phone: normalizedPhone, password });
    const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "30d" });

    res.status(201).json({
      token,
      user: { id: user.id, name: user.name, email: user.email, phone: user.phone },
    });
  })
);

app.post(
  "/auth/login",
  asyncHandler(async (req, res) => {
    const { phone, email, password } = req.body || {};
    if ((!phone && !email) || !password) {
      return res.status(400).json({ error: "phone or email and password are required" });
    }

    let user = null;
    if (phone) user = await getUserByPhone(phone);
    else if (email) user = await getUserByEmail(email);

    if (!user || !user.password_hash) {
      return res.status(401).json({ error: "Invalid login or password" });
    }

    const ok = bcrypt.compareSync(password, user.password_hash);
    if (!ok) return res.status(401).json({ error: "Invalid login or password" });

    const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "30d" });
    res.json({
      token,
      user: { id: user.id, name: user.name, email: user.email, phone: user.phone },
    });
  })
);

// -------------------------
// Me (User endpoints)
// -------------------------
app.get(
  "/me",
  requireUser,
  asyncHandler(async (req, res) => {
    const user = await getUserById(req.user.id);
    if (!user) return res.status(404).json({ error: "User not found" });
    res.json({ id: user.id, name: user.name, email: user.email, phone: user.phone });
  })
);

app.get(
  "/me/devices",
  requireUser,
  asyncHandler(async (req, res) => {
    const userId = req.user.id;
    const r = await q(
      `
      SELECT d.id, d.name, du.role
      FROM device_users du
      JOIN devices d ON d.id = du.device_id
      WHERE du.user_id = $1
      ORDER BY d.id
      `,
      [userId]
    );
    res.json(r.rows);
  })
);

// User alerts feed (derived)
app.get(
  "/me/alerts",
  requireUser,
  asyncHandler(async (req, res) => {
    const userId = req.user.id;
    const deviceId = (req.query.deviceId || "").trim() || null;
    const since = (req.query.since || "").trim() || null;
    const limit = req.query.limit ? Math.max(1, Math.min(5000, Number(req.query.limit) || 200)) : 200;

    const rows = await getUserAlerts({ userId, deviceId, since, limit });
    res.json(rows || []);
  })
);

// -------------------------
// Devices (Admin)
// -------------------------
app.get(
  "/devices",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    res.json(await getDevices());
  })
);

app.post(
  "/devices",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const body = req.body || {};
    const id = (body.id || "").trim();
    const name = (body.name || "").trim();

    if (!id) return res.status(400).json({ error: "id is required" });
    if (!name) return res.status(400).json({ error: "name is required" });

    // Check ID uniqueness
    const existing = await getDeviceById(id);
    if (existing) return res.status(409).json({ error: "Device with this id already exists" });

    // Check NAME uniqueness (case-insensitive / trimmed)
    const existingByName = await getDeviceByName(name);
    if (existingByName) return res.status(409).json({ error: "Device with this name already exists" });

    const device = await createDevice(id, name);
    res.status(201).json(device);
  })
);

// -------------------------
// Alert subscriptions (Admin) - ONE canonical GET + PUT
// -------------------------

// GET enabled/disabled rows for one user on one gate
app.get(
  "/devices/:id/alert-subs",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const deviceId = req.params.id;
    const userId = (req.query.userId || "").trim();
    if (!userId) return res.status(400).json({ error: "userId is required" });

    const r = await q(
      `SELECT device_id, user_id, event_type, enabled
       FROM device_notifications_subscriptions
       WHERE device_id = $1 AND user_id = $2
       ORDER BY event_type`,
      [deviceId, userId]
    );

    res.json(r.rows);
  })
);

// PUT replaces enabled event types (simple UX: send enabled list)
app.put(
  "/devices/:id/alert-subs",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const deviceId = req.params.id;
    const userId = (req.body?.userId || "").trim();
    const enabledEventTypes = Array.isArray(req.body?.enabledEventTypes) ? req.body.enabledEventTypes : [];

    if (!userId) return res.status(400).json({ error: "userId is required" });

    await q(`DELETE FROM device_notifications_subscriptions WHERE device_id=$1 AND user_id=$2`, [deviceId, userId]);

    for (const ev of enabledEventTypes) {
      const eventType = String(ev || "").trim();
      if (!eventType) continue;
      await q(
        `INSERT INTO device_notifications_subscriptions (device_id, user_id, event_type, enabled)
         VALUES ($1, $2, $3, true)`,
        [deviceId, userId, eventType]
      );
    }

    res.json({ status: "ok", deviceId, userId, enabledEventTypes });
  })
);

// -------------------------
// Device users (Admin)
// -------------------------
app.get(
  "/devices/:id/users",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const deviceId = req.params.id;
    const device = await getDeviceById(deviceId);
    if (!device) return res.status(404).json({ error: "Device not found" });

    res.json(await listDeviceUsers(deviceId));
  })
);

app.post(
  "/devices/:id/users",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const deviceId = req.params.id;
    const device = await getDeviceById(deviceId);
    if (!device) return res.status(404).json({ error: "Device not found" });

    const { userId, name, email, phone, password, role } = req.body || {};
    const rRole = role || "operator";

    let user = null;

    // If UI sends userId (most common), attach existing user
    if (userId) {
      user = await getUserById(userId);
      if (!user) return res.status(404).json({ error: "User not found for given userId" });
      await attachUserToDevice(deviceId, user.id, rRole);
      return res.status(201).json({
        deviceId,
        userId: user.id,
        role: rRole,
        user: { id: user.id, name: user.name, email: user.email, phone: user.phone },
      });
    }

    // Otherwise allow “create or find” by email/phone
    if (!email && !phone) {
      return res.status(400).json({ error: "At least email or phone is required (or provide userId)" });
    }

    const normalizedPhone = normalizePhone(phone);
    if (normalizedPhone) user = await getUserByPhone(normalizedPhone);
    if (!user && email) user = await getUserByEmail(email);

    if (!user) {
      user = await createUser({ name, email, phone: normalizedPhone, password });
    } else if (password && password.length > 0) {
      user = await updateUser(user.id, {
        name: name || user.name,
        email: email || user.email,
        phone: normalizedPhone || user.phone,
        password,
      });
    } else if (name || email || normalizedPhone) {
      user = await updateUser(user.id, {
        name: name || user.name,
        email: email || user.email,
        phone: normalizedPhone || user.phone,
        password: null,
      });
    }

    await attachUserToDevice(deviceId, user.id, rRole);

    res.status(201).json({
      deviceId,
      userId: user.id,
      role: rRole,
      user: { id: user.id, name: user.name, email: user.email, phone: user.phone },
    });
  })
);

app.delete(
  "/devices/:id/users/:userId",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const removed = await detachUserFromDevice(req.params.id, req.params.userId);
    if (!removed) return res.status(404).json({ error: "Not found" });
    res.json({ status: "removed", deviceId: req.params.id, userId: req.params.userId });
  })
);

app.put(
  "/devices/:id/users/:userId/schedule-assignment",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const deviceId = req.params.id;
    const userId = req.params.userId;

    const device = await getDeviceById(deviceId);
    if (!device) return res.status(404).json({ error: "Device not found" });

    const user = await getUserById(userId);
    if (!user) return res.status(404).json({ error: "User not found" });

    const scheduleId = req.body && req.body.scheduleId ? Number(req.body.scheduleId) : null;
    if (scheduleId) {
      const sched = await getScheduleById(scheduleId);
      if (!sched) return res.status(404).json({ error: "Schedule not found" });
    }

    await setDeviceUserSchedule(deviceId, userId, scheduleId || null);
    res.json({ deviceId, userId, scheduleId: scheduleId || null });
  })
);

// -------------------------
// Device Settings (Admin)
// -------------------------
app.get(
  "/devices/:deviceId/settings",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const deviceId = req.params.deviceId;
    const r = await pool.query("select settings from public.device_settings where device_id = $1", [deviceId]);
    if (r.rows.length === 0) return res.json({});
    return res.json(r.rows[0].settings || {});
  })
);

app.put(
  "/devices/:deviceId/settings",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const deviceId = req.params.deviceId;
    const settings = req.body || {};
    const r = await pool.query(
      `
      insert into public.device_settings (device_id, settings, updated_at)
      values ($1, $2::jsonb, now())
      on conflict (device_id)
      do update set settings = excluded.settings, updated_at = now()
      returning settings
      `,
      [deviceId, JSON.stringify(settings)]
    );
    return res.json(r.rows[0].settings || {});
  })
);

// -------------------------
// Purge old events (Admin)
// -------------------------
app.post(
  "/admin/purge-events",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const olderThanDays = Number(req.body?.olderThanDays);
    if (!Number.isFinite(olderThanDays) || olderThanDays < 1) {
      return res.status(400).json({ error: "olderThanDays must be a number >= 1" });
    }
    const r = await pool.query(
      `delete from public.device_events
       where at < (now() - make_interval(days => $1))`,
      [olderThanDays]
    );
    return res.json({ ok: true, deleted: r.rowCount });
  })
);

// -------------------------
// Schedules (Admin)
// -------------------------
app.get(
  "/schedules",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    res.json(await listSchedules());
  })
);

app.post(
  "/schedules",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const body = req.body || {};
    const name = (body.name || "").trim();
    if (!name) return res.status(400).json({ error: "name is required" });

    const description = (body.description || "").trim();
    const slots = Array.isArray(body.slots) ? body.slots : [];
    const cleanSlots = slots
      .filter((s) => s && s.start && s.end)
      .map((s) => ({
        daysOfWeek: Array.isArray(s.daysOfWeek) ? s.daysOfWeek : [],
        start: s.start,
        end: s.end,
      }));

    const sched = await createSchedule({ name, description, slots: cleanSlots });
    res.status(201).json(sched);
  })
);

app.put(
  "/schedules/:id",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const id = Number(req.params.id);
    if (!id) return res.status(400).json({ error: "Invalid schedule id" });

    const body = req.body || {};
    const name = (body.name || "").trim();
    if (!name) return res.status(400).json({ error: "name is required" });

    const description = (body.description || "").trim();
    const slots = Array.isArray(body.slots) ? body.slots : [];
    const cleanSlots = slots
      .filter((s) => s && s.start && s.end)
      .map((s) => ({
        daysOfWeek: Array.isArray(s.daysOfWeek) ? s.daysOfWeek : [],
        start: s.start,
        end: s.end,
      }));

    const sched = await updateSchedule(id, { name, description, slots: cleanSlots });
    if (!sched) return res.status(404).json({ error: "Schedule not found" });
    res.json(sched);
  })
);

app.delete(
  "/schedules/:id",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const id = Number(req.params.id);
    if (!id) return res.status(400).json({ error: "Invalid schedule id" });
    await deleteSchedule(id);
    res.json({ status: "deleted", id });
  })
);

// -------------------------
// Users (Admin)
// -------------------------

// GET /admin/users (alias)
app.get(
  "/admin/users",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const qstr = (req.query.q || "").trim();
    const rows = await searchUsers(qstr || null);

    const result = [];
    for (const u of rows) {
      const devices = await listUserDevices(u.id);
      result.push({ id: u.id, name: u.name, email: u.email, phone: u.phone, devices });
    }
    res.json(result);
  })
);

// POST /admin/users (admin create)
app.post(
  "/admin/users",
  requireAdminKey,
  asyncHandler(async (req, res) => {
    const body = req.body || {};
    const name = (body.name || "").trim();
    const email = (body.email || "").trim() || null;
    const phone = normalizePhone(body.phone || null);
    const password = body.password || "";

    if (!password) return res.status(400).json({ error: "password is required" });
    if (!email && !phone) return res.status(400).json({ error: "Provide at least email or phone" });

    if (phone) {
      const existingByPhone = await getUserByPhone(phone);
      if (existingByPhone) return res.status(409).json({ error: "User with this phone already exists" });
    }
    if (email) {
      const existingByEmail = await getUserByEmail(email);
      if (existingByEmail) return res.status(409).json({ error: "User with this email already exists" });
    }

    const user = await createUser({ name, email, phone
