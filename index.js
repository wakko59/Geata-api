// index.js (Postgres / Supabase)
// Same API behaviour as SQLite version, but using pg + async handlers.

const express = require('express');
const path = require('path');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { Pool } = require('pg');

const app = express();
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

const ADMIN_API_KEY = process.env.ADMIN_API_KEY || 'dev-only-admin-key';
const JWT_SECRET = process.env.JWT_SECRET || 'dev-only-jwt-secret';
const PORT = process.env.PORT || 3000;

const DATABASE_URL = process.env.DATABASE_URL;
if (!DATABASE_URL) {
  console.warn('*** WARNING: DATABASE_URL is not set (Postgres will not connect). ***');
}

const pool = new Pool({
  connectionString: DATABASE_URL,
  ssl: process.env.PGSSL === 'true' ? { rejectUnauthorized: false } : false
});


function asyncHandler(fn) {
  return (req, res, next) => Promise.resolve(fn(req, res, next)).catch(next);
}
async function q(text, params = []) {
  return pool.query(text, params);
}
async function one(text, params = []) {
  const r = await q(text, params);
  return r.rows[0] || null;
}

// ---- DB INIT ----

async function initDb() {
  await q(`
    CREATE TABLE IF NOT EXISTS devices (
      id   TEXT PRIMARY KEY,
      name TEXT NOT NULL
    );

    CREATE TABLE IF NOT EXISTS users (
      id            TEXT PRIMARY KEY,
      name          TEXT NOT NULL,
      email         TEXT UNIQUE,
      phone         TEXT,
      password_hash TEXT
    );

    CREATE TABLE IF NOT EXISTS schedules (
      id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      name        TEXT NOT NULL,
      description TEXT,
      created_at  TEXT NOT NULL
    );

    CREATE TABLE IF NOT EXISTS schedule_slots (
      id           INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      schedule_id  INTEGER NOT NULL REFERENCES schedules(id) ON DELETE CASCADE,
      days_of_week TEXT,
      start        TEXT NOT NULL,
      "end"        TEXT NOT NULL
    );

    CREATE TABLE IF NOT EXISTS device_users (
      device_id   TEXT NOT NULL REFERENCES devices(id) ON DELETE CASCADE,
      user_id     TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      role        TEXT NOT NULL,
      schedule_id INTEGER REFERENCES schedules(id) ON DELETE SET NULL,
      PRIMARY KEY (device_id, user_id)
    );

    CREATE TABLE IF NOT EXISTS commands (
      id           TEXT PRIMARY KEY,
      device_id    TEXT NOT NULL REFERENCES devices(id) ON DELETE CASCADE,
      user_id      TEXT REFERENCES users(id) ON DELETE SET NULL,
      type         TEXT NOT NULL,
      status       TEXT NOT NULL,
      requested_at TEXT NOT NULL,
      completed_at TEXT,
      result       TEXT,
      duration_ms  INTEGER NOT NULL
    );

    CREATE TABLE IF NOT EXISTS device_events (
      id         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      device_id  TEXT NOT NULL REFERENCES devices(id) ON DELETE CASCADE,
      user_id    TEXT REFERENCES users(id) ON DELETE SET NULL,
      event_type TEXT NOT NULL,
      at         TEXT NOT NULL,
      details    TEXT
    );

    CREATE INDEX IF NOT EXISTS idx_device_users_user ON device_users(user_id);
    CREATE INDEX IF NOT EXISTS idx_commands_device_status_req ON commands(device_id, status, requested_at);
    CREATE INDEX IF NOT EXISTS idx_device_events_device_at ON device_events(device_id, at);
    CREATE INDEX IF NOT EXISTS idx_device_events_user_at ON device_events(user_id, at);
    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
    CREATE INDEX IF NOT EXISTS idx_users_phone ON users(phone);
  `);

  const row = await one('SELECT COUNT(*)::int AS c FROM devices');
  if ((row?.c || 0) === 0) {
    await q(
      `INSERT INTO devices (id, name) VALUES ($1,$2),($3,$4)
       ON CONFLICT (id) DO NOTHING`,
      ['gate1', 'Example Gate 1', 'gate2', 'Example Gate 2']
    );
  }
}

// ---- Helpers ----

function normalizePhone(raw) {
  if (!raw) return null;
  return String(raw).trim();
}

function randomId(prefix) {
  return prefix + '_' + Date.now() + '_' + Math.floor(Math.random() * 100000);
}

// Devices

async function getDevices() {
  const r = await q('SELECT id, name FROM devices ORDER BY id');
  return r.rows;
}

async function getDeviceById(id) {
  return one('SELECT id, name FROM devices WHERE id = $1', [id]);
}

async function createDevice(id, name) {
  await q('INSERT INTO devices (id, name) VALUES ($1, $2)', [id, name]);
  return getDeviceById(id);
}

// Users

async function getUserById(id) {
  return one('SELECT * FROM users WHERE id = $1', [id]);
}

async function getUserByEmail(email) {
  if (!email) return null;
  return one('SELECT * FROM users WHERE email = $1', [email]);
}

async function getUserByPhone(phone) {
  const p = normalizePhone(phone);
  if (!p) return null;
  return one('SELECT * FROM users WHERE phone = $1', [p]);
}

async function createUser({ name, email, phone, password }) {
  const id = randomId('u');
  const normalizedPhone = normalizePhone(phone);
  const hash = password ? bcrypt.hashSync(password, 10) : null;

  await q(
    'INSERT INTO users (id, name, email, phone, password_hash) VALUES ($1,$2,$3,$4,$5)',
    [
      id,
      name || email || normalizedPhone || id,
      email || null,
      normalizedPhone || null,
      hash
    ]
  );
  return getUserById(id);
}

async function updateUser(id, { name, email, phone, password }) {
  const user = await getUserById(id);
  if (!user) return null;

  const newName = name != null && name !== '' ? name : user.name;
  const newEmail = email != null && email !== '' ? email : user.email;
  const newPhone = phone != null && phone !== '' ? normalizePhone(phone) : user.phone;

  let newHash = user.password_hash;
  if (password && password.length > 0) {
    newHash = bcrypt.hashSync(password, 10);
  }

  await q(
    'UPDATE users SET name=$1, email=$2, phone=$3, password_hash=$4 WHERE id=$5',
    [newName, newEmail, newPhone, newHash, id]
  );
  return getUserById(id);
}

async function deleteUser(id) {
  await q('DELETE FROM device_users WHERE user_id = $1', [id]);
  await q('DELETE FROM users WHERE id = $1', [id]);
}

async function searchUsers(qstr) {
  if (!qstr) {
    const r = await q('SELECT * FROM users ORDER BY LOWER(name)');
    return r.rows;
  }
  const pattern = '%' + qstr + '%';
  const r = await q(
    `
    SELECT *
    FROM users
    WHERE name  ILIKE $1
       OR email ILIKE $1
       OR phone ILIKE $1
    ORDER BY LOWER(name)
    `,
    [pattern]
  );
  return r.rows;
}

// Device-users

async function attachUserToDevice(deviceId, userId, role) {
  const r = role || 'operator';
  await q(
    `
    INSERT INTO device_users (device_id, user_id, role)
    VALUES ($1,$2,$3)
    ON CONFLICT (device_id, user_id) DO NOTHING
    `,
    [deviceId, userId, r]
  );
  return { deviceId, userId, role: r };
}

async function detachUserFromDevice(deviceId, userId) {
  const r = await q(
    'DELETE FROM device_users WHERE device_id=$1 AND user_id=$2',
    [deviceId, userId]
  );
  return r.rowCount > 0;
}

async function setDeviceUserSchedule(deviceId, userId, scheduleId) {
  await q(
    `
    UPDATE device_users
    SET schedule_id = $1
    WHERE device_id = $2 AND user_id = $3
    `,
    [scheduleId || null, deviceId, userId]
  );
}

async function listDeviceUsers(deviceId) {
  const r = await q(
    `
    SELECT
      du.user_id     AS "userId",
      du.role        AS "role",
      du.schedule_id AS "scheduleId",
      u.name         AS "name",
      u.email        AS "email",
      u.phone        AS "phone"
    FROM device_users du
    LEFT JOIN users u ON u.id = du.user_id
    WHERE du.device_id = $1
    ORDER BY LOWER(u.name)
    `,
    [deviceId]
  );
  return r.rows;
}

async function listUserDevices(userId) {
  const r = await q(
    `
    SELECT du.device_id AS "deviceId",
           du.role      AS "role"
    FROM device_users du
    WHERE du.user_id = $1
    ORDER BY du.device_id
    `,
    [userId]
  );
  return r.rows;
}

async function isUserOnDevice(deviceId, userId) {
  const row = await one(
    'SELECT 1 AS present FROM device_users WHERE device_id=$1 AND user_id=$2',
    [deviceId, userId]
  );
  return !!row;
}

async function getDeviceUserScheduleId(deviceId, userId) {
  const row = await one(
    'SELECT schedule_id FROM device_users WHERE device_id=$1 AND user_id=$2',
    [deviceId, userId]
  );
  return row ? row.schedule_id : null;
}

// Schedules

async function getScheduleSlots(scheduleId) {
  const r = await q(
    `
    SELECT id, schedule_id, days_of_week, start, "end" AS end
    FROM schedule_slots
    WHERE schedule_id = $1
    ORDER BY id
    `,
    [scheduleId]
  );
  return r.rows;
}

async function getScheduleById(id) {
  const row = await one(
    'SELECT id, name, description, created_at FROM schedules WHERE id = $1',
    [id]
  );
  if (!row) return null;

  const slotsRows = await getScheduleSlots(id);
  const slots = slotsRows.map(s => ({
    id: s.id,
    scheduleId: s.schedule_id,
    daysOfWeek: s.days_of_week ? JSON.parse(s.days_of_week) : [],
    start: s.start,
    end: s.end
  }));

  return {
    id: row.id,
    name: row.name,
    description: row.description,
    createdAt: row.created_at,
    slots
  };
}

async function listSchedules() {
  const r = await q(
    'SELECT id, name, description, created_at FROM schedules ORDER BY LOWER(name)'
  );

  const out = [];
  for (const sched of r.rows) {
    const slotsRows = await getScheduleSlots(sched.id);
    const slots = slotsRows.map(s => ({
      id: s.id,
      scheduleId: s.schedule_id,
      daysOfWeek: s.days_of_week ? JSON.parse(s.days_of_week) : [],
      start: s.start,
      end: s.end
    }));
    out.push({
      id: sched.id,
      name: sched.name,
      description: sched.description,
      createdAt: sched.created_at,
      slots
    });
  }
  return out;
}

async function createSchedule({ name, description, slots }) {
  const createdAt = new Date().toISOString();
  const info = await one(
    `
    INSERT INTO schedules (name, description, created_at)
    VALUES ($1,$2,$3)
    RETURNING id
    `,
    [name, description || null, createdAt]
  );
  const scheduleId = info.id;

  if (Array.isArray(slots)) {
    for (const s of slots) {
      const daysJson =
        Array.isArray(s.daysOfWeek) && s.daysOfWeek.length > 0
          ? JSON.stringify(s.daysOfWeek)
          : null;

      await q(
        `INSERT INTO schedule_slots (schedule_id, days_of_week, start, "end")
         VALUES ($1,$2,$3,$4)`,
        [scheduleId, daysJson, s.start, s.end]
      );
    }
  }

  return getScheduleById(scheduleId);
}

async function updateSchedule(id, { name, description, slots }) {
  const existing = await getScheduleById(id);
  if (!existing) return null;

  await q(
    'UPDATE schedules SET name=$1, description=$2 WHERE id=$3',
    [name || existing.name, description || null, id]
  );

  await q('DELETE FROM schedule_slots WHERE schedule_id = $1', [id]);

  if (Array.isArray(slots)) {
    for (const s of slots) {
      const daysJson =
        Array.isArray(s.daysOfWeek) && s.daysOfWeek.length > 0
          ? JSON.stringify(s.daysOfWeek)
          : null;

      await q(
        `INSERT INTO schedule_slots (schedule_id, days_of_week, start, "end")
         VALUES ($1,$2,$3,$4)`,
        [id, daysJson, s.start, s.end]
      );
    }
  }

  return getScheduleById(id);
}

async function deleteSchedule(id) {
  await q('UPDATE device_users SET schedule_id = NULL WHERE schedule_id = $1', [id]);
  await q('DELETE FROM schedule_slots WHERE schedule_id = $1', [id]);
  await q('DELETE FROM schedules WHERE id = $1', [id]);
}

// Schedule check

async function isUserAllowedNow(deviceId, userId, now) {
  now = now || new Date();

  if (!(await isUserOnDevice(deviceId, userId))) return false;

  const scheduleId = await getDeviceUserScheduleId(deviceId, userId);
  if (!scheduleId) return true; // 24/7

  const sched = await getScheduleById(scheduleId);
  if (!sched || !sched.slots || sched.slots.length === 0) return false;

  const day = now.getDay(); // 0â€“6
  const hh = now.getHours();
  const mm = now.getMinutes();
  const pad = n => (n < 10 ? '0' + n : '' + n);
  const timeStr = pad(hh) + ':' + pad(mm);

  for (const s of sched.slots) {
    const days = Array.isArray(s.daysOfWeek) ? s.daysOfWeek : [];
    if (days.length > 0 && days.indexOf(day) === -1) continue;
    if (s.start && timeStr < s.start) continue;
    if (s.end && timeStr > s.end) continue;
    return true;
  }
  return false;
}

// Commands & events

async function logDeviceEvent(deviceId, eventType, opts) {
  opts = opts || {};
  const userId = opts.userId || null;
  const details = opts.details || null;
  const at = new Date().toISOString();

  await q(
    `INSERT INTO device_events (device_id, user_id, event_type, at, details)
     VALUES ($1,$2,$3,$4,$5)`,
    [deviceId, userId, eventType, at, details]
  );
}

async function createCommand(deviceId, userId, type, durationMs) {
  const id = randomId('cmd');
  const nowIso = new Date().toISOString();

  await q(
    `INSERT INTO commands
      (id, device_id, user_id, type, status, requested_at, completed_at, result, duration_ms)
     VALUES ($1,$2,$3,$4,'queued',$5,NULL,NULL,$6)`,
    [id, deviceId, userId || null, type, nowIso, durationMs]
  );

  await logDeviceEvent(deviceId, 'CMD_REQUESTED', {
    userId: userId || null,
    details: `type=${type};durationMs=${durationMs}`
  });

  return {
    id,
    deviceId,
    userId: userId || null,
    type,
    status: 'queued',
    requestedAt: nowIso,
    completedAt: null,
    result: null,
    durationMs
  };
}

async function getQueuedCommands(deviceId) {
  const r = await q(
    `SELECT * FROM commands
     WHERE device_id=$1 AND status='queued'
     ORDER BY requested_at ASC`,
    [deviceId]
  );
  return r.rows;
}

async function completeCommand(deviceId, commandId, result) {
  const nowIso = new Date().toISOString();
  await q(
    `UPDATE commands
     SET status='completed', completed_at=$1, result=$2
     WHERE id=$3 AND device_id=$4 AND status='queued'`,
    [nowIso, result || null, commandId, deviceId]
  );
  return one('SELECT * FROM commands WHERE id = $1', [commandId]);
}

async function listRecentCommands(limit) {
  const lim = limit || 20;
  const r = await q(
    `SELECT * FROM commands
     ORDER BY requested_at DESC
     LIMIT $1`,
    [lim]
  );
  return r.rows;
}

async function getDeviceEvents(deviceId, limit) {
  const lim = limit || 50;
  const r = await q(
    `
    SELECT
      e.id, e.device_id, e.user_id, e.event_type, e.at, e.details,
      u.name  AS user_name,
      u.phone AS user_phone
    FROM device_events e
    LEFT JOIN users u ON u.id = e.user_id
    WHERE e.device_id = $1
    ORDER BY e.at DESC
    LIMIT $2
    `,
    [deviceId, lim]
  );
  return r.rows;
}

async function getEventsForReport(filters) {
  const deviceId = filters.deviceId || null;
  const userId = filters.userId || null;
  const from = filters.from || null;
  const to = filters.to || null;
  const limit = filters.limit || 500;

  let sql = `
    SELECT
      e.id, e.device_id, e.user_id, e.event_type, e.at, e.details,
      u.name  AS user_name,
      u.phone AS user_phone,
      u.email AS user_email,
      d.name  AS device_name
    FROM device_events e
    LEFT JOIN users   u ON u.id = e.user_id
    LEFT JOIN devices d ON d.id = e.device_id
    WHERE 1=1
  `;
  const params = [];
  let i = 1;

  if (deviceId) { sql += ` AND e.device_id = $${i++}`; params.push(deviceId); }
  if (userId)   { sql += ` AND e.user_id = $${i++}`;   params.push(userId); }
  if (from)     { sql += ` AND e.at >= $${i++}`;       params.push(from); }
  if (to)       { sql += ` AND e.at <= $${i++}`;       params.push(to); }

  sql += ` ORDER BY e.at DESC LIMIT $${i++}`;
  params.push(limit);

  const r = await q(sql, params);
  return r.rows;
}

// ---- Middleware ----

function requireAdminKey(req, res, next) {
  const key = req.header('x-api-key');
  if (!key || key !== ADMIN_API_KEY) {
    return res.status(401).json({ error: 'Unauthorized: missing or invalid API key' });
  }
  next();
}

function requireUser(req, res, next) {
  const auth = req.header('authorization') || '';
  if (!auth.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Missing auth token' });
  }
  const token = auth.slice(7);
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = { id: payload.userId };
    next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}

// ---- Routes ----

// Health
app.get('/', (req, res) => {
  res.send('Geata API is running');
});

// Auth

app.post('/auth/register', asyncHandler(async (req, res) => {
  const { name, email, phone, password } = req.body || {};
  if (!password || (!email && !phone)) {
    return res.status(400).json({ error: 'password and at least phone or email are required' });
  }

  const normalizedPhone = normalizePhone(phone);
  if (normalizedPhone) {
    const existingByPhone = await getUserByPhone(normalizedPhone);
    if (existingByPhone) return res.status(409).json({ error: 'User with this phone already exists' });
  }
  if (email) {
    const existingByEmail = await getUserByEmail(email);
    if (existingByEmail) return res.status(409).json({ error: 'User with this email already exists' });
  }

  const user = await createUser({ name, email, phone: normalizedPhone, password });
  const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '30d' });

  res.status(201).json({
    token,
    user: { id: user.id, name: user.name, email: user.email, phone: user.phone }
  });
}));

app.post('/auth/login', asyncHandler(async (req, res) => {
  const { phone, email, password } = req.body || {};
  if ((!phone && !email) || !password) {
    return res.status(400).json({ error: 'phone or email and password are required' });
  }

  let user = null;
  if (phone) user = await getUserByPhone(phone);
  else if (email) user = await getUserByEmail(email);

  if (!user || !user.password_hash) {
    return res.status(401).json({ error: 'Invalid login or password' });
  }

  const ok = bcrypt.compareSync(password, user.password_hash);
  if (!ok) return res.status(401).json({ error: 'Invalid login or password' });

  const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '30d' });
  res.json({
    token,
    user: { id: user.id, name: user.name, email: user.email, phone: user.phone }
  });
}));

// Me

app.get('/me', requireUser, asyncHandler(async (req, res) => {
  const user = await getUserById(req.user.id);
  if (!user) return res.status(404).json({ error: 'User not found' });
  res.json({ id: user.id, name: user.name, email: user.email, phone: user.phone });
}));

app.get('/me/devices', requireUser, asyncHandler(async (req, res) => {
  const userId = req.user.id;
  const r = await q(
    `
    SELECT d.id, d.name, du.role
    FROM device_users du
    JOIN devices d ON d.id = du.device_id
    WHERE du.user_id = $1
    ORDER BY d.id
    `,
    [userId]
  );
  res.json(r.rows);
}));

// Devices (NOW ADMIN-ONLY GET as requested)

app.get('/devices', requireAdminKey, asyncHandler(async (req, res) => {
  res.json(await getDevices());
}));

app.post('/devices', requireAdminKey, asyncHandler(async (req, res) => {
  const { id, name } = req.body || {};
  if (!id || !name) return res.status(400).json({ error: 'id and name are required' });

  const existing = await getDeviceById(id);
  if (existing) return res.status(409).json({ error: 'Device with this id already exists' });

  const dev = await createDevice(id, name);
  res.status(201).json(dev);
}));

// Device users

app.get('/devices/:id/users', requireAdminKey, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });
  res.json(await listDeviceUsers(deviceId));
}));

app.post('/devices/:id/users', requireAdminKey, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });

  const { userId, name, email, phone, password, role } = req.body || {};
  const r = role || 'operator';

  let user = null;

  if (userId) {
    user = await getUserById(userId);
    if (!user) return res.status(404).json({ error: 'User not found for given userId' });
    await attachUserToDevice(deviceId, user.id, r);
    return res.status(201).json({
      deviceId,
      userId: user.id,
      role: r,
      user: { id: user.id, name: user.name, email: user.email, phone: user.phone }
    });
  }

  if (!email && !phone) {
    return res.status(400).json({ error: 'At least email or phone is required (or provide userId)' });
  }

  const normalizedPhone = normalizePhone(phone);
  if (normalizedPhone) user = await getUserByPhone(normalizedPhone);
  if (!user && email) user = await getUserByEmail(email);

  if (!user) {
    user = await createUser({ name, email, phone: normalizedPhone, password });
  } else if (password && password.length > 0) {
    user = await updateUser(user.id, {
      name: name || user.name,
      email: email || user.email,
      phone: normalizedPhone || user.phone,
      password
    });
  } else if (name || email || normalizedPhone) {
    user = await updateUser(user.id, {
      name: name || user.name,
      email: email || user.email,
      phone: normalizedPhone || user.phone,
      password: null
    });
  }

  await attachUserToDevice(deviceId, user.id, r);

  res.status(201).json({
    deviceId,
    userId: user.id,
    role: r,
    user: { id: user.id, name: user.name, email: user.email, phone: user.phone }
  });
}));

app.post('/devices/:id/users/import', requireAdminKey, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });

  const rows = req.body && req.body.rows;
  if (!Array.isArray(rows)) return res.status(400).json({ error: 'rows array is required' });

  const created = [];
  const reused = [];

  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    for (const r of rows) {
      const name = (r.name || '').trim();
      const email = (r.email || '').trim();
      const phone = normalizePhone(r.phone || '');
      const role = (r.role || 'operator').trim() || 'operator';

      if (!email && !phone) continue;

      let user = null;
      if (phone) {
        const rr = await client.query('SELECT * FROM users WHERE phone = $1', [phone]);
        user = rr.rows[0] || null;
      }
      if (!user && email) {
        const rr = await client.query('SELECT * FROM users WHERE email = $1', [email]);
        user = rr.rows[0] || null;
      }

      if (!user) {
        const id = randomId('u');
        await client.query(
          'INSERT INTO users (id, name, email, phone, password_hash) VALUES ($1,$2,$3,$4,$5)',
          [id, name || email || phone || id, email || null, phone || null, null]
        );
        const rr = await client.query('SELECT * FROM users WHERE id = $1', [id]);
        user = rr.rows[0];
        created.push(user.id);
      } else {
        reused.push(user.id);
      }

      await client.query(
        `
        INSERT INTO device_users (device_id, user_id, role)
        VALUES ($1,$2,$3)
        ON CONFLICT (device_id, user_id) DO NOTHING
        `,
        [deviceId, user.id, role]
      );
    }

    await client.query('COMMIT');
  } catch (e) {
    await client.query('ROLLBACK');
    throw e;
  } finally {
    client.release();
  }

  res.json({ created, reused });
}));

app.get('/devices/:id/users/export', requireAdminKey, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });

  const rows = await listDeviceUsers(deviceId);

  const header = ['userId', 'name', 'email', 'phone', 'role', 'scheduleId'];
  const csvRows = [header.join(',')];

  for (const r of rows) {
    const out = [
      r.userId,
      r.name || '',
      r.email || '',
      r.phone || '',
      r.role || '',
      r.scheduleId || ''
    ].map(v => '"' + String(v == null ? '' : v).replace(/"/g, '""') + '"');
    csvRows.push(out.join(','));
  }

  const csv = csvRows.join('\r\n');
  res.setHeader('Content-Type', 'text/csv');
  res.setHeader('Content-Disposition', `attachment; filename="device-${deviceId}-users.csv"`);
  res.send(csv);
}));

app.get('/users/export-csv', requireAdminKey, asyncHandler(async (req, res) => {
  const users = (await q(`SELECT id, name, email, phone FROM users ORDER BY id`)).rows;

  const du = (await q(`
    SELECT du.user_id, du.device_id, du.role, d.name AS device_name
    FROM device_users du
    LEFT JOIN devices d ON d.id = du.device_id
  `)).rows;

  const devicesByUser = {};
  for (const row of du) {
    if (!devicesByUser[row.user_id]) devicesByUser[row.user_id] = [];
    const label =
      row.device_id +
      (row.device_name ? `(${row.device_name})` : '') +
      ':' +
      (row.role || 'operator');
    devicesByUser[row.user_id].push(label);
  }

  const header = ['userId', 'name', 'email', 'phone', 'devices'];
  const csvRows = [header.join(',')];

  for (const u of users) {
    const devs = (devicesByUser[u.id] || []).join(' | ');
    const out = [u.id, u.name || '', u.email || '', u.phone || '', devs].map(v => {
      const s = String(v == null ? '' : v);
      return '"' + s.replace(/"/g, '""') + '"';
    });
    csvRows.push(out.join(','));
  }

  const csv = csvRows.join('\r\n');
  res.setHeader('Content-Type', 'text/csv');
  res.setHeader('Content-Disposition', 'attachment; filename="geata-users-devices.csv"');
  res.send(csv);
}));

app.delete('/devices/:id/users/:userId', requireAdminKey, asyncHandler(async (req, res) => {
  const removed = await detachUserFromDevice(req.params.id, req.params.userId);
  if (!removed) return res.status(404).json({ error: 'Not found' });
  res.json({ status: 'removed', deviceId: req.params.id, userId: req.params.userId });
}));

app.put('/devices/:id/users/:userId/schedule-assignment', requireAdminKey, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const userId = req.params.userId;

  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });

  const user = await getUserById(userId);
  if (!user) return res.status(404).json({ error: 'User not found' });

  const scheduleId = req.body && req.body.scheduleId ? Number(req.body.scheduleId) : null;
  if (scheduleId) {
    const sched = await getScheduleById(scheduleId);
    if (!sched) return res.status(404).json({ error: 'Schedule not found' });
  }

  await setDeviceUserSchedule(deviceId, userId, scheduleId || null);
  res.json({ deviceId, userId, scheduleId: scheduleId || null });
}));

// Schedules

app.get('/schedules', requireAdminKey, asyncHandler(async (req, res) => {
  res.json(await listSchedules());
}));

app.post('/schedules', requireAdminKey, asyncHandler(async (req, res) => {
  const body = req.body || {};
  const name = (body.name || '').trim();
  if (!name) return res.status(400).json({ error: 'name is required' });

  const description = (body.description || '').trim();
  const slots = Array.isArray(body.slots) ? body.slots : [];
  const cleanSlots = slots
    .filter(s => s && s.start && s.end)
    .map(s => ({
      daysOfWeek: Array.isArray(s.daysOfWeek) ? s.daysOfWeek : [],
      start: s.start,
      end: s.end
    }));

  const sched = await createSchedule({ name, description, slots: cleanSlots });
  res.status(201).json(sched);
}));

app.put('/schedules/:id', requireAdminKey, asyncHandler(async (req, res) => {
  const id = Number(req.params.id);
  if (!id) return res.status(400).json({ error: 'Invalid schedule id' });

  const body = req.body || {};
  const name = (body.name || '').trim();
  if (!name) return res.status(400).json({ error: 'name is required' });

  const description = (body.description || '').trim();
  const slots = Array.isArray(body.slots) ? body.slots : [];
  const cleanSlots = slots
    .filter(s => s && s.start && s.end)
    .map(s => ({
      daysOfWeek: Array.isArray(s.daysOfWeek) ? s.daysOfWeek : [],
      start: s.start,
      end: s.end
    }));

  const sched = await updateSchedule(id, { name, description, slots: cleanSlots });
  if (!sched) return res.status(404).json({ error: 'Schedule not found' });
  res.json(sched);
}));

app.delete('/schedules/:id', requireAdminKey, asyncHandler(async (req, res) => {
  const id = Number(req.params.id);
  if (!id) return res.status(400).json({ error: 'Invalid schedule id' });
  await deleteSchedule(id);
  res.json({ status: 'deleted', id });
}));

// Users (admin)

app.get('/users', requireAdminKey, asyncHandler(async (req, res) => {
  const qstr = (req.query.q || '').trim();
  const rows = await searchUsers(qstr || null);

  const result = [];
  for (const u of rows) {
    const devices = await listUserDevices(u.id);
    result.push({ id: u.id, name: u.name, email: u.email, phone: u.phone, devices });
  }
  res.json(result);
}));

app.put('/users/:id', requireAdminKey, asyncHandler(async (req, res) => {
  const id = req.params.id;
  const user = await getUserById(id);
  if (!user) return res.status(404).json({ error: 'User not found' });

  const updated = await updateUser(id, {
    name: req.body && req.body.name,
    email: req.body && req.body.email,
    phone: req.body && req.body.phone,
    password: req.body && req.body.password
  });

  res.json({ id: updated.id, name: updated.name, email: updated.email, phone: updated.phone });
}));

app.delete('/users/:id', requireAdminKey, asyncHandler(async (req, res) => {
  const id = req.params.id;
  const user = await getUserById(id);
  if (!user) return res.status(404).json({ error: 'User not found' });
  await deleteUser(id);
  res.json({ status: 'deleted', id });
}));

// User-facing open gate

app.post('/devices/:id/open', requireUser, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });

  const userId = req.user.id;
  const durationMs = req.body && req.body.durationMs ? Number(req.body.durationMs) : 1000;

  if (!(await isUserOnDevice(deviceId, userId))) {
    await logDeviceEvent(deviceId, 'ACCESS_DENIED_NOT_ASSIGNED', { userId, details: 'open' });
    return res.status(403).json({ error: 'User not allowed on this device' });
  }

  if (!(await isUserAllowedNow(deviceId, userId, new Date()))) {
    await logDeviceEvent(deviceId, 'ACCESS_DENIED_SCHEDULE', { userId, details: 'open' });
    return res.status(403).json({ error: 'Access not allowed at this time' });
  }

  const cmd = await createCommand(deviceId, userId, 'OPEN', durationMs);
  await logDeviceEvent(deviceId, 'OPEN_REQUESTED', { userId, details: 'durationMs=' + durationMs });
  res.status(201).json(cmd);
}));

app.post('/devices/:id/aux1', requireUser, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });

  const userId = req.user.id;
  const durationMs = req.body && req.body.durationMs ? Number(req.body.durationMs) : 1000;

  if (!(await isUserOnDevice(deviceId, userId))) {
    await logDeviceEvent(deviceId, 'AUX1_DENIED_NOT_ASSIGNED', { userId, details: 'aux1' });
    return res.status(403).json({ error: 'User not allowed on this device' });
  }

  if (!(await isUserAllowedNow(deviceId, userId, new Date()))) {
    await logDeviceEvent(deviceId, 'AUX1_DENIED_SCHEDULE', { userId, details: 'aux1' });
    return res.status(403).json({ error: 'Access not allowed at this time' });
  }

  const cmd = await createCommand(deviceId, userId, 'AUX1', durationMs);
  await logDeviceEvent(deviceId, 'AUX1_REQUESTED', { userId, details: 'durationMs=' + durationMs });
  res.status(201).json(cmd);
}));

app.post('/devices/:id/aux2', requireUser, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });

  const userId = req.user.id;
  const durationMs = req.body && req.body.durationMs ? Number(req.body.durationMs) : 1000;

  if (!(await isUserOnDevice(deviceId, userId))) {
    await logDeviceEvent(deviceId, 'AUX2_DENIED_NOT_ASSIGNED', { userId, details: 'aux2' });
    return res.status(403).json({ error: 'User not allowed on this device' });
  }

  if (!(await isUserAllowedNow(deviceId, userId, new Date()))) {
    await logDeviceEvent(deviceId, 'AUX2_DENIED_SCHEDULE', { userId, details: 'aux2' });
    return res.status(403).json({ error: 'Access not allowed at this time' });
  }

  const cmd = await createCommand(deviceId, userId, 'AUX2', durationMs);
  await logDeviceEvent(deviceId, 'AUX2_REQUESTED', { userId, details: 'durationMs=' + durationMs });
  res.status(201).json(cmd);
}));

// AUX tests (admin)

app.post('/devices/:id/aux1-test', requireAdminKey, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });
  const durationMs = req.body && req.body.durationMs ? Number(req.body.durationMs) : 1000;
  const cmd = await createCommand(deviceId, null, 'AUX1', durationMs);
  await logDeviceEvent(deviceId, 'AUX1_TRIGGER', { details: 'durationMs=' + durationMs });
  res.status(201).json(cmd);
}));

app.post('/devices/:id/aux2-test', requireAdminKey, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });
  const durationMs = req.body && req.body.durationMs ? Number(req.body.durationMs) : 1000;
  const cmd = await createCommand(deviceId, null, 'AUX2', durationMs);
  await logDeviceEvent(deviceId, 'AUX2_TRIGGER', { details: 'durationMs=' + durationMs });
  res.status(201).json(cmd);
}));

// Simulated gate inputs (admin)

app.post('/devices/:id/simulate-event', requireAdminKey, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });
  const type = (req.body && req.body.type) || 'UNKNOWN';
  await logDeviceEvent(deviceId, type, { details: 'simulated=true' });
  res.json({ status: 'ok', deviceId, type });
}));

// Device events per gate (admin)

app.get('/devices/:id/events', requireAdminKey, asyncHandler(async (req, res) => {
  const deviceId = req.params.id;
  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not found' });
  const limit = req.query.limit ? Number(req.query.limit) || 50 : 50;
  res.json(await getDeviceEvents(deviceId, limit));
}));

// Global reports (admin)

app.get('/events', requireAdminKey, asyncHandler(async (req, res) => {
  const deviceId = (req.query.deviceId || '').trim() || null;
  const userId = (req.query.userId || '').trim() || null;
  const from = (req.query.from || '').trim() || null;
  const to = (req.query.to || '').trim() || null;
  const limit = req.query.limit ? Number(req.query.limit) || 500 : 500;
  const format = (req.query.format || 'json').toLowerCase();

  const events = await getEventsForReport({ deviceId, userId, from, to, limit });

  if (format === 'csv') {
    let csv = 'timestamp,deviceId,deviceName,userId,userName,userPhone,eventType,details\r\n';
    events.forEach(ev => {
      const row = [
        ev.at || '',
        ev.device_id || '',
        ev.device_name || '',
        ev.user_id || '',
        ev.user_name || '',
        ev.user_phone || '',
        ev.event_type || '',
        ev.details || ''
      ];
      csv += row
        .map(val => '"' + String(val || '').replace(/"/g, '""') + '"')
        .join(',') + '\r\n';
    });
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename="events-report.csv"');
    return res.send(csv);
  }

  res.json(events);
}));

// Commands listing (admin)

app.get('/commands', requireAdminKey, asyncHandler(async (req, res) => {
  const limit = req.query.limit ? Number(req.query.limit) || 20 : 20;
  res.json(await listRecentCommands(limit));
}));

// ESP poll endpoint (no auth yet)

app.post('/device/poll', asyncHandler(async (req, res) => {
  const body = req.body || {};
  const deviceId = body.deviceId;
  const lastResults = Array.isArray(body.lastResults) ? body.lastResults : [];

  if (!deviceId) return res.status(400).json({ error: 'deviceId is required' });

  const device = await getDeviceById(deviceId);
  if (!device) return res.status(404).json({ error: 'Device not registered' });

  for (const r of lastResults) {
    if (!r || !r.commandId) continue;
    const cmdRow = await completeCommand(deviceId, r.commandId, r.result || '');
    if (cmdRow) {
      await logDeviceEvent(deviceId, 'CMD_COMPLETED', {
        userId: cmdRow.user_id || null,
        details: cmdRow.type + ' result=' + (r.result || '')
      });
    }
  }

  const queued = await getQueuedCommands(deviceId);
  const toSend = queued.map(c => ({
    commandId: c.id,
    type: c.type,
    durationMs: c.duration_ms
  }));

  res.json({ commands: toSend });
}));

// Error handler
app.use((err, req, res, next) => {
  console.error('*** UNHANDLED ERROR ***', err);
  res.status(500).json({ error: 'Internal server error' });
});

// ---- Start server ----
async function start() {
  // Ensure DB is ready before accepting traffic
  await initDb();
  app.listen(PORT, () => {
    console.log(`Geata API listening on port ${PORT}`);
    // IMPORTANT: don't print the key in production logs
    if (process.env.NODE_ENV !== 'production') {
      console.log(`Admin API key is: ${ADMIN_API_KEY}`);
    }
  });
}

if (require.main === module) {
  start().catch(err => {
    console.error('*** initDb FAILED ***', err);
    process.exit(1);
  });
}

// Export for tests
module.exports = { app, initDb, pool };


// graceful shutdown
process.on('SIGTERM', async () => {
  try { await pool.end(); } catch (_) {}
  process.exit(0);
});
process.on('SIGINT', async () => {
  try { await pool.end(); } catch (_) {}
  process.exit(0);
});
